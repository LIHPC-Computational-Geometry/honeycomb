<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Insert `n` vertices in an edge, cutting it into `n+1` segments."><title>insert_vertices_on_edge in honeycomb::prelude::cell_insertion - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="honeycomb" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (859951e3c 2026-02-24)" data-channel="nightly" data-search-js="search-63369b7b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../../static.files/storage-41dd4d93.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5013f961.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">insert_vertices_on_edge</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../honeycomb/index.html">honeycomb</a><span class="version">0.10.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">insert_<wbr>vertices_<wbr>on_<wbr>edge</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#arguments" title="Arguments">Arguments</a><ul><li><a href="#dart-ids-requirements--usage" title="Dart IDs Requirements &#38; Usage">Dart IDs Requirements &amp; Usage</a></li></ul></li><li><a href="#errors" title="Errors">Errors</a></li><li><a href="#example" title="Example">Example</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In honeycomb::<wbr>prelude::<wbr>cell_<wbr>insertion</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">honeycomb</a>::<wbr><a href="../index.html">prelude</a>::<wbr><a href="index.html">cell_insertion</a></div><h1>Function <span class="fn">insert_<wbr>vertices_<wbr>on_<wbr>edge</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/honeycomb_kernels/cell_insertion/vertices.rs.html#302-308">Source</a> </span></div><pre class="rust item-decl"><code>pub fn insert_vertices_on_edge&lt;T&gt;(
    cmap: &amp;<a class="struct" href="../struct.CMap2.html" title="struct honeycomb::prelude::CMap2">CMap2</a>&lt;T&gt;,
    t: &amp;mut Transaction,
    edge_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>,
    new_darts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>],
    midpoint_vertices: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[T]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, TransactionError&lt;<a class="enum" href="enum.VertexInsertionError.html" title="enum honeycomb::prelude::cell_insertion::VertexInsertionError">VertexInsertionError</a>&gt;&gt;<div class="where">where
    T: <a class="trait" href="../trait.CoordsFloat.html" title="trait honeycomb::prelude::CoordsFloat">CoordsFloat</a>,</div></code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>kernels</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Insert <code>n</code> vertices in an edge, cutting it into <code>n+1</code> segments.</p>
<div class="warning">
This implementation is 2D specific.
</div>
<h2 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h2>
<ul>
<li><code>cmap: &amp;mut CMap2&lt;T&gt;</code> – Reference to the modified map.</li>
<li><code>t: &amp;mut Transaction</code> – Associated transaction.</li>
<li><code>edge_id: EdgeIdentifier</code> – Target edge.</li>
<li><code>new_darts: &amp;[DartIdentifier]</code> – Dart IDs used to build the new vertices/segments.</li>
<li><code>midpoint_vertices: &amp;[T]</code> – Relative positions of new vertices, starting from the
vertex of the dart sharing <code>edge_id</code> as its identifier.</li>
</ul>
<h3 id="dart-ids-requirements--usage"><a class="doc-anchor" href="#dart-ids-requirements--usage">§</a>Dart IDs Requirements &amp; Usage</h3>
<p>Because of the dimension, we can easily compute the number of dart needed to perform this
operation. These are the requirements for the darts:</p>
<ul>
<li>identifiers are passed as a slice:
<ul>
<li>slice length should verify <code>new_darts.len() == 2 * midpoint_vertices.len()</code></li>
</ul>
</li>
<li>the first half of the slice will always be used if the operation is successful.</li>
<li>the second half of the slice will only be used if the original edge is made of two darts;
if that is not the case, the second half IDs can all be <code>NULL_DART_ID</code>s.</li>
<li>all of these darts should be free</li>
</ul>
<h2 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h2>
<p>This function will abort and raise an error if:</p>
<ul>
<li>the transaction cannot be completed,</li>
<li>a hypothesis over input isn’t verified (see <a href="enum.VertexInsertionError.html" title="enum honeycomb::prelude::cell_insertion::VertexInsertionError"><code>VertexInsertionError</code></a>),</li>
<li>an internal operation failed.</li>
</ul>
<p>The returned error can be used in conjunction with transaction control to avoid any
modifications in case of failure at attribute level. The user can then choose to retry or
abort as he wishes using <code>Transaction::with_control_and_err</code>.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// before
//    &lt;--2---
//  1         2
//    ---1--&gt;

</span><span class="kw">let </span><span class="kw-2">mut </span>map: CMap2&lt;<span class="kw">_</span>&gt; = CMapBuilder::&lt;<span class="number">2</span>&gt;::from_n_darts(<span class="number">2</span>)
                            .build()
                            .unwrap();
map.force_link::&lt;<span class="number">2</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);
map.force_write_vertex(<span class="number">1</span>, (<span class="number">0.0</span>, <span class="number">0.0</span>));
map.force_write_vertex(<span class="number">2</span>, (<span class="number">1.0</span>, <span class="number">0.0</span>));

<span class="kw">let </span>nd = map.allocate_unused_darts(<span class="number">6</span>);

<span class="comment">// split
</span><span class="macro">assert!</span>(
    atomically_with_err(|t| insert_vertices_on_edge(
        <span class="kw-2">&amp;</span>map,
        t,
        <span class="number">1</span>,
        <span class="kw-2">&amp;</span>[nd, nd + <span class="number">1</span>, nd + <span class="number">2</span>, nd + <span class="number">3</span>, nd + <span class="number">4</span>, nd + <span class="number">5</span>],
        <span class="kw-2">&amp;</span>[<span class="number">0.25</span>, <span class="number">0.50</span>, <span class="number">0.75</span>],
    )).is_ok()
);

<span class="comment">// after
//    &lt;-&lt;-&lt;-&lt;
//  1 -3-4-5- 2
//    &gt;-&gt;-&gt;-&gt;

// checks
</span><span class="kw">let </span>new_darts = [
    map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">1</span>),
    map.beta::&lt;<span class="number">1</span>&gt;(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">1</span>)),
    map.beta::&lt;<span class="number">1</span>&gt;(map.beta::&lt;<span class="number">1</span>&gt;(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">1</span>))),
];
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>new_darts, <span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="macro">assert_eq!</span>(map.force_read_vertex(<span class="number">3</span>), <span class="prelude-val">Some</span>(Vertex2(<span class="number">0.25</span>, <span class="number">0.0</span>)));
<span class="macro">assert_eq!</span>(map.force_read_vertex(<span class="number">4</span>), <span class="prelude-val">Some</span>(Vertex2(<span class="number">0.50</span>, <span class="number">0.0</span>)));
<span class="macro">assert_eq!</span>(map.force_read_vertex(<span class="number">5</span>), <span class="prelude-val">Some</span>(Vertex2(<span class="number">0.75</span>, <span class="number">0.0</span>)));

<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">1</span>), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">3</span>), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">4</span>), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">5</span>), NULL_DART_ID);

<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">2</span>), <span class="number">6</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">6</span>), <span class="number">7</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">7</span>), <span class="number">8</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">1</span>&gt;(<span class="number">8</span>), NULL_DART_ID);

<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">2</span>&gt;(<span class="number">1</span>), <span class="number">8</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">2</span>&gt;(<span class="number">3</span>), <span class="number">7</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">2</span>&gt;(<span class="number">4</span>), <span class="number">6</span>);
<span class="macro">assert_eq!</span>(map.beta::&lt;<span class="number">2</span>&gt;(<span class="number">5</span>), <span class="number">2</span>);</code></pre></div></div></details></section></div></main></body></html>