<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrency / Parallelism - Honeycomb - User Guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome</a></li><li class="chapter-item expanded affix "><li class="part-title">Project Structure</li><li class="chapter-item expanded "><a href="../project-structure/workspace.html"><strong aria-hidden="true">1.</strong> Workspace</a></li><li class="chapter-item expanded "><a href="../project-structure/published.html"><strong aria-hidden="true">2.</strong> Published crates</a></li><li class="chapter-item expanded "><a href="../project-structure/others.html"><strong aria-hidden="true">3.</strong> Other content</a></li><li class="chapter-item expanded "><a href="../project-structure/contributing.html"><strong aria-hidden="true">4.</strong> Contributing</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="../usage/attributes.html"><strong aria-hidden="true">5.</strong> Adding generic attributes to maps</a></li><li class="chapter-item expanded "><a href="../usage/stm.html" class="active"><strong aria-hidden="true">6.</strong> Concurrency / Parallelism</a></li><li class="chapter-item expanded "><a href="../usage/serialization.html"><strong aria-hidden="true">7.</strong> Serialization</a></li><li class="chapter-item expanded affix "><li class="part-title">Kernels</li><li class="chapter-item expanded "><a href="../kernels/grisubal.html"><strong aria-hidden="true">8.</strong> Grisubal</a></li><li class="chapter-item expanded "><a href="../kernels/triangulations.html"><strong aria-hidden="true">9.</strong> Polygon triangulation</a></li><li class="chapter-item expanded "><a href="../kernels/remeshing.html"><strong aria-hidden="true">10.</strong> Remeshing</a></li><li class="chapter-item expanded affix "><li class="part-title">Definitions</li><li class="chapter-item expanded "><a href="../definitions/introduction.html"><strong aria-hidden="true">11.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../definitions/cmaps.html"><strong aria-hidden="true">12.</strong> Combinatorial Maps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../definitions/darts.html"><strong aria-hidden="true">12.1.</strong> Darts</a></li><li class="chapter-item expanded "><a href="../definitions/betaf.html"><strong aria-hidden="true">12.2.</strong> Beta Functions</a></li><li class="chapter-item expanded "><a href="../definitions/orbits.html"><strong aria-hidden="true">12.3.</strong> Orbits</a></li><li class="chapter-item expanded "><a href="../definitions/embedding.html"><strong aria-hidden="true">12.4.</strong> Embedding</a></li></ol></li><li class="chapter-item expanded "><a href="../definitions/basicops.html"><strong aria-hidden="true">13.</strong> Basic Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../definitions/changeNdim.html"><strong aria-hidden="true">13.1.</strong> Add / Remove a dimension</a></li><li class="chapter-item expanded "><a href="../definitions/changeNdart.html"><strong aria-hidden="true">13.2.</strong> Add / Remove a free dart</a></li><li class="chapter-item expanded "><a href="../definitions/sew.html"><strong aria-hidden="true">13.3.</strong> Sewing / Unsewing operation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Honeycomb - User Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="using-maps-in-concurrent--parallel-contexts"><a class="header" href="#using-maps-in-concurrent--parallel-contexts">Using maps in concurrent / parallel contexts</a></h1>
<hr />
<h2 id="needs"><a class="header" href="#needs">Needs</a></h2>
<p>Rust's ownership semantics require us to add synchronization mechanism to our structure if we want
to use it in concurrent contexts. Using primitives such as atomics and mutexes would be enough to
get programs to compile, but it would respectively yield an incorrect or impractical implementation:</p>
<ul>
<li>Atomics give guarantees on instructions interleaving for a single given variable, they do not give
any guarantees for instructions affecting different atomic variables.</li>
<li>Mutexes (and similar locks, e.g. RWLocks) can be used to create guarantees when accessing multiple
variable: for example, we can write an operation that does not progress until all of the used data
is locked. However, locks are error-prone, have very poor composability.</li>
</ul>
<p>The nature of meshing operations disqualify both mechanisms. They are complex, access many
variables, and are often comprised of multiple steps. For example, the following operation is
executed on all affected attributes of a sew:</p>
<figure style="text-align:center">
    <img src="../images/attribute_merge.svg" alt="Merge Operation" />
    <figcaption><i>Attribute merging operation. This occurs at each sew operation.</i></figcaption>
</figure>
<p>Because the map can go through invalid intermediate states during a single operation, we need to
ensure another thread will not use one of these as the starting point for another operation. This
rules out atomic variables.</p>
<p>The sew operation is the main method used to create new connectivities in the map. This means that
most high-level meshing operations will call this method multiple times. If these meshing operations
require locking all of the variables to ensure correct execution, the locks must be returned or
exposed to the user so that he can unlock them at the right time. Manual lock management is
error-prone, and becomes impossible in practice for complex meshing operations.</p>
<h2 id="software-transactional-memory"><a class="header" href="#software-transactional-memory">Software Transactional Memory</a></h2>
<p>We choose to use Software Transactional Memory (STM) to handle high-level synchronization of
the structure. Unlike locks, STM has great composability and allows users of the crate to easily
define pseudo-atomic segments in their own algorithms.</p>
<p>Exposing an API that allows users to handle synchronization also means that the implementation
isn't bound to a given parallelization framework. Instead of relying on predefinite parallel
routines (e.g. a provided <code>parallel_for</code> on given cells), the structure can be used to implement
existing algorithms regardless of their approach (data-oriented, task-based, ...).</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>To illustrate all of this, we provide two examples: one using <code>rayon</code>, and the other using
<code>std::thread</code>. The former focus exclusively on avoiding conflicts while the latter includes
transactions fallible due to meshing errors.</p>
<h3 id="move-all-vertices-to-the-average-of-their-neighbors"><a class="header" href="#move-all-vertices-to-the-average-of-their-neighbors">Move all vertices to the average of their neighbors</a></h3>
<p>In the following routine, we shift each vertex that's not on a boundary to the average of its
neighbors positions. In this case, transactions allow us to ensure we won't compute a new
position from a value that has been replaced since the start of the computation.</p>
<h4 id="code"><a class="header" href="#code">Code</a></h4>
<pre><pre class="playground"><code class="language-rust">use honeycomb_core::{
    cmap::{CMap2, DartIdType, OrbitPolicy, VertexIdType, NULL_DART_ID},
    geometry::Vertex2,
    stm::atomically,
};
use honeycomb_kernels::grid_generation::GridBuilder;
use rayon::prelude::*;

const N_SQUARES: usize = 256;
const N_ROUNDS: usize = 100;

fn main() {
    let map: CMap2&lt;f64&gt; = GridBuilder::&lt;2, _&gt;::unit_triangles(N_SQUARES);

    // fetch all vertices that are not on the boundary of the map
    let nodes: Vec&lt;(VertexIdType, Vec&lt;VertexIdType&gt;)&gt; = map
        .iter_vertices()
        .filter_map(|v| {
            // the condition detects if we're on the boundary
            if map
                .orbit(OrbitPolicy::Vertex, v as DartIdType)
                .any(|d| map.beta::&lt;2&gt;(d) == NULL_DART_ID)
            {
                None
            } else {
                // the orbit transformation yields neighbor IDs
                Some((
                    v,
                    map.orbit(OrbitPolicy::Vertex, v as DartIdType)
                        .map(|d| map.vertex_id(map.beta::&lt;2&gt;(d)))
                        .collect(),
                ))
            }
        })
        .collect();

    // main loop
    let mut round = 0;
    loop {
        // process nodes in parallel
        nodes.par_iter().for_each(|(vid, neigh)| {
            // we need a transaction here to avoid UBs, since there's
            // no guarantee we won't process neighbor nodes concurrently
            //
            // the transaction will ensure that we do not validate an operation
            // where inputs have changed due to instruction interleaving between threads
            // here, it will retry the transaction until it can be validated
            atomically(|trans| {
                let mut new_val = Vertex2::default();
                for v in neigh {
                    let vertex = map.read_vertex(trans, *v)?.unwrap();
                    new_val.0 += vertex.0;
                    new_val.1 += vertex.1;
                }
                new_val.0 /= neigh.len() as f64;
                new_val.1 /= neigh.len() as f64;
                map.write_vertex(trans, *vid, new_val)
            });
        });

        round += 1;
        if round &gt;= N_ROUNDS {
            break;
        }
    }

    std::hint::black_box(map);
}</code></pre></pre>
<h4 id="breakdown"><a class="header" href="#breakdown">Breakdown</a></h4>
<p>The main map structure, <code>CMap2</code>, can be edited in parallel using transactions to ensure algorithm
correctness.</p>
<p>In the main computation loop, we use a transaction to ensure each new vertex value is computed from
the current neighbor's values. The errors generated by <code>read_vertex</code> and <code>write_vertex</code> are used to
(early) detect any changes to the data used in the transaction, here, the list of <code>neigh</code> vertices.</p>
<p>At the end of the transaction block, the commit routine will check again if any used data has been
altered. If not, results of the transaction will be validated and written to memory.</p>
<h3 id="cut-all-squares-of-a-grid-into-triangles"><a class="header" href="#cut-all-squares-of-a-grid-into-triangles">Cut all squares of a grid into triangles</a></h3>
<p>In the following routine, we generate an orthogonal grid and split all of its cells diagonally.
While no beta values should be edited concurrently, synchronization is necessary to protect the
integrity of <em>I</em>-cells and their bound attributes (here, spatial coordinates).</p>
<h4 id="code-1"><a class="header" href="#code-1">Code</a></h4>
<pre><pre class="playground"><code class="language-rust">use honeycomb_core::{
    cmap::{CMap2, CMapBuilder, DartIdType}
    stm::atomically_with_err,
};

const DIM_GRID: usize = 256;
const N_THREADS: usize = 8;

fn main() {
    let mut map: CMap2&lt;_&gt; = CMapBuilder::&lt;2, f64&gt;::unit_grid(DIM_GRID).build().unwrap();

    // build individual work units
    let faces = map.iter_faces().collect::&lt;Vec&lt;_&gt;&gt;();
    let nd = map.add_free_darts(faces.len() * 2);
    let nd_range = (nd..nd + (faces.len() * 2) as DartIdType).collect::&lt;Vec&lt;_&gt;&gt;();
    let units = faces
        .into_iter()
        .zip(nd_range.chunks(2))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    std::thread::scope(|s| {
        // create batches &amp; move a copy to dispatched thread
        let batches = units.chunks(1 + units.len() / N_THREADS);
        for b in batches {
            s.spawn(|| {
                let locb = b.to_vec();
                locb.into_iter().for_each(|(df, sl)| {
                    let square = df as DartIdType;
                    let &amp;[dsplit1, dsplit2] = sl else {
                        unreachable!()
                    };
                    // we know dart numbering since we constructed a regular grid
                    let (ddown, dright, dup, dleft) = (square, square + 1, square + 2, square + 3);
                    let (dbefore1, dbefore2, dafter1, dafter2) = (ddown, dup, dleft, dright);

                    let _ = map.force_link::&lt;2&gt;(dsplit1, dsplit2); // infallible

                    // internal (un)sews can fail, so we retry until success
                    while atomically_with_err(|trans| {
                        map.unsew::&lt;1&gt;(trans, dbefore1)?;
                        map.unsew::&lt;1&gt;(trans, dbefore2)?;
                        map.sew::&lt;1&gt;(trans, dsplit1, dafter1)?;
                        map.sew::&lt;1&gt;(trans, dsplit2, dafter2)?;

                        map.sew::&lt;1&gt;(trans, dbefore1, dsplit1)?;
                        map.sew::&lt;1&gt;(trans, dbefore2, dsplit2)?;
                        Ok(())
                    })
                    .is_err()
                    {}
                });
            });
        }
    });

    std::hint::black_box(map);
}</code></pre></pre>
<h4 id="breakdown-1"><a class="header" href="#breakdown-1">Breakdown</a></h4>
<p>In this example, we create batches of work for each thread to process. The exact reason we require
transactions here is due to STM implementation specificities. While some STM algorithms fully
prevent operating on invalid data (eager), others will not detect this until there is an attempt
to commit the transaction (lazy). The implementation we use is among the latter.</p>
<p>This implies that, if conflicting operations are executed concurrently, any check for invariants
we do in our algorithm can fail due to an inconsistent data state. Practically, we can simply
use a fallible transaction (that's <code>atomically_with_err</code>) to define our atomic segment, and handle
the error like any other.</p>
<p>In the above example, transactions are retried until success, since we can guarantee that only
valid data states are committed; that implies transactions will eventually succeed, albeit after
many retries.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../usage/attributes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../usage/serialization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../usage/attributes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../usage/serialization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
